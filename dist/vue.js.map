{"version":3,"file":"vue.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA","sources":["webpack://Vue/./compiler2/index.js","webpack://Vue/./compiler2/mountComponent.js","webpack://Vue/./compiler2/patch.js","webpack://Vue/./compiler2/renderHelper.js","webpack://Vue/./compiler2/vnode.js","webpack://Vue/./dep.js","webpack://Vue/./observer.js","webpack://Vue/./protoArgument.js","webpack://Vue/./src/utils/index.js","webpack://Vue/./utils.js","webpack://Vue/./vue.js","webpack://Vue/./watcher.js","webpack://Vue/webpack/bootstrap","webpack://Vue/webpack/runtime/define property getters","webpack://Vue/webpack/runtime/hasOwnProperty shorthand","webpack://Vue/webpack/runtime/make namespace object","webpack://Vue/webpack/before-startup","webpack://Vue/webpack/startup","webpack://Vue/webpack/after-startup"],"sourcesContent":["import { mountComponent } from './mountComponent';\r\n/**\r\n * Vue2\r\n * @param { Vue } vm \r\n */\r\nexport function mount(vm) {\r\n    // 没有提供 render 选项，则编译生成 render 函数\r\n    if (!vm.$options.render) {\r\n        \r\n        let template = '';\r\n        if (vm.$options.template) {\r\n            // 优先模板\r\n            template = vm.$options.template;\r\n\r\n        } else if (vm.$options.el) {\r\n            // el 选项\r\n            vm.$el = document.querySelector(vm.$options.el);\r\n            template = vm.$el.outerHTML;\r\n        }\r\n\r\n        const render = compileToFunction(template);\r\n\r\n        vm.$options.render = render;\r\n    }\r\n    mountComponent(vm);\r\n}\r\n\r\n/**\r\n * 解析模版字符串，得到 AST 语法树\r\n * 将 AST 语法树生成渲染函数\r\n * @param { String } template 模板字符串\r\n * @return { Function } 渲染函数\r\n */\r\nfunction compileToFunction(template) {\r\n    // 解析模版，生成 ast\r\n    const ast = parse(template);\r\n\r\n    const render = generate(ast);\r\n\r\n    return render;\r\n}\r\n\r\n/**\r\n * 将模板解析成 AST\r\n * @param {*} template \r\n */\r\nfunction parse(template) {\r\n    // 存放所有的未配对的开始标签的 AST 对象\r\n    const stack = [];\r\n    // 最终的 AST 语法树\r\n    let root = null;\r\n\r\n    let html = template;\r\n\r\n    while(html.trim()) {\r\n        // 注释标签 直接忽视\r\n        if (html.indexOf('<!--') === 0) {\r\n            html = html.slice(html.indexOf('-->') + 3);\r\n            continue;\r\n        }\r\n\r\n        // 匹配开始标签\r\n        const startIdx = html.indexOf('<');\r\n        if (startIdx === 0) {\r\n            if (html.indexOf('</') === 0) {\r\n                // 闭合标签\r\n                parseEnd();\r\n            } else {\r\n                // 开始标签\r\n                parseStartTag();\r\n            }\r\n        } else if (startIdx > 0) {\r\n            // 说明开始标签之前还有其他文本\r\n\r\n            /*\r\n                如果栈为空，说明该段文本不属于任何标签，即无需处理\r\n            */\r\n            if (stack.length) {\r\n                // 文本属于栈顶元素\r\n                processChars(html.slice(0, startIdx));\r\n            }\r\n            html = html.slice(startIdx);\r\n        } else {\r\n            // 说明没有匹配到开始标签，整个 html 就是一段文本\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 处理开始标签\r\n     * '<div class=\"name\">xxx</div>'\r\n     */\r\n    function parseStartTag() {\r\n        // 开始标签的结束位置\r\n        const end = html.indexOf('>');\r\n        /*\r\n            div class=\"name\"\r\n            用于解析标签名称与属性\r\n        */\r\n        const content = html.slice(1, end);\r\n\r\n        // 截断html，剩余部分为未处理的模板字符串\r\n        html = html.slice(end + 1);\r\n        // 第一个空格位置\r\n        const firstSpaceIdx = content.indexOf(' ');\r\n\r\n        let tagName, // 标签名\r\n            attrName; // 属性名\r\n        \r\n        if (firstSpaceIdx === -1) {\r\n            // <p>xxx</p> 这种格式下就没有空格,content就是标签名\r\n            tagName = content;\r\n        } else {\r\n            tagName = content.slice(0, firstSpaceIdx);\r\n            // 剩余的就是属性名\r\n            attrName = content.slice(firstSpaceIdx + 1);\r\n        }\r\n\r\n        // 属性名数组 [class=\"name\", id=\"xxx\"]\r\n        const attrs = attrName ? attrName.split(' ') : [];\r\n        // 解析属性数组\r\n        const attrMap = parseAttrs(attrs);\r\n        // 生成 ast\r\n        const elementAst = generateAST(tagName, attrMap);\r\n        // 如果根节点不存在，说明当前节点为整个模版的第一个节点\r\n        if (!root) {\r\n            root = elementAst;\r\n        }\r\n        // 将开始标签放入 栈顶，等遇到结束标签就 出队，就形成一个完整标签\r\n        stack.push(elementAst);\r\n\r\n        // 自闭和标签\r\n        if (isUnaryTag(tagName)) {\r\n            processElement();\r\n        }\r\n    }\r\n    /**\r\n     * 闭合标签\r\n     */\r\n    function parseEnd() {\r\n        html = html.slice(html.indexOf('>') + 1);\r\n        // 栈顶元素出队，表示与该闭合标签配套的标签已经处理\r\n        processElement();\r\n    }\r\n\r\n    /**\r\n     * 处理完闭合标签后调用\r\n     */\r\n    function processElement() {\r\n        // 弹出栈顶元素，进一步处理该元素\r\n        const curEle = stack.pop();\r\n        const stackLen = stack.length;\r\n\r\n        const { tag, rawAttr } = curEle;\r\n\r\n        // 处理结果都放到 attr 对象上\r\n        curEle.attr = {};\r\n\r\n        for (let key in rawAttr) {\r\n            if (key === 'v-model') {\r\n                // 处理 v-model\r\n                processVModel(curEle);\r\n            } else if (/^v-bind:(.*)$/.test(key)) {\r\n                // 处理 v-bind\r\n                processVBind(curEle.attr, RegExp.$1, rawAttr[key]);\r\n            } else if (/^v-on:(.*)$/.test(key)) {\r\n                // 处理 v-on\r\n                processVOn(curEle.attr, RegExp.$1, rawAttr[key]);\r\n            }\r\n        }\r\n\r\n        // 栈顶的元素是下层元素的子元素\r\n        if (stackLen > 0) {\r\n            stack[stack.length - 1].children.push(curEle);\r\n            curEle.parent = stack[stack.length - 1];\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * 处理 文本\r\n     */\r\n    function processChars(text) {\r\n        if (!text.trim()) return;\r\n\r\n        const textAST = {\r\n            type: 3,\r\n            text,\r\n        };\r\n\r\n        if (text.match(/{{(.*)}}/)) {\r\n            // 说明是表达式\r\n            textAST.expression = RegExp.$1.trim();\r\n        }\r\n        // 将 ast 放到栈顶元素的肚子里\r\n        stack[stack.length - 1].children.push(textAST);\r\n    }\r\n\r\n    return root;\r\n}\r\n\r\n/**\r\n * 解析属性数组\r\n * @param { Array[] } attrs\r\n * @return { Object } 属性名：属性值\r\n */\r\nfunction parseAttrs(attrs) {\r\n    const attrMap = {};\r\n\r\n    for (let i = 0; i < attrs.length; i++) {\r\n        const [attrName, attrValue] = attrs[i].split('=');\r\n\r\n        attrMap[attrName] = attrValue ? attrValue.replace(/['\"]/g, '') : undefined;\r\n    }\r\n\r\n    return attrMap;\r\n}\r\n\r\n/**\r\n * 生成 AST\r\n * @param { String } tagName \r\n * @param { Object } attrMap \r\n */\r\nfunction generateAST(tagName, attrMap) {\r\n    return {\r\n        // 元素节点\r\n        type: 1,\r\n        // 标签\r\n        tag: tagName,\r\n        rawAttr: attrMap,\r\n        // 子元素\r\n        children: [],\r\n    }\r\n}\r\n\r\n/**\r\n * 处理 v-model\r\n * @param {} curEle\r\n */\r\nfunction processVModel(curEle) {\r\n    const { tag, attr, rawAttr } = curEle;\r\n    const { type, 'v-model': vModelValue } = rawAttr;\r\n\r\n    if (tag === 'input') {\r\n        if (type.trim() === 'text') {\r\n            // <input type=\"text\" v-model=\"value\" />\r\n            attr.vModel = { tag, type: 'text', value: vModelValue };\r\n        } else if (type.trim() === 'checkbox') {\r\n            // <input type=\"checkbox\" v-model=\"checked\" />\r\n            attr.vModel = { tag, type: 'checkbox', value: vModelValue };\r\n        }\r\n    } else if (tag === 'textarea') {\r\n        // <textarea v-model=\"value\" />\r\n        attr.vModel = { tag, value: vModelVal };\r\n    } else if (tag === 'select') {\r\n        // <select v-model=\"value\">...</select>\r\n        attr.vModel = { tag, value: vModelVal };\r\n    }\r\n}\r\n\r\n/**\r\n * 处理 v-bind\r\n * @param {*} attr\r\n * @param {*} key\r\n * @param {*} value \r\n */\r\nfunction processVBind(attr, key, value) {\r\n    let vBind = attr.vBind;\r\n    if (!vBind) {\r\n        vBind = attr.vBind = {};\r\n    }\r\n    vBind[key] = value;\r\n}\r\n\r\n/**\r\n * 处理 v-on\r\n * @param {*} attr \r\n * @param {*} key \r\n * @param {*} value \r\n */\r\nfunction processVOn(attr, key, value) {\r\n    let vOn = attr.vOn;\r\n    if (!vOn) {\r\n        vOn = attr.vOn = {};\r\n    }\r\n    vOn[key] = value;\r\n}\r\n\r\n/**\r\n * 判断是否自闭和标签\r\n * @param {*} tagName \r\n */\r\nfunction isUnaryTag(tagName) {\r\n    const unaryTag = ['input'];\r\n    return unaryTag.includes(tagName);\r\n}\r\n\r\n/**\r\n * ast 生成 渲染函数\r\n * @param {*} ast\r\n * @return { Function } 可执行的渲染函数\r\n */\r\nfunction generate(ast) {\r\n    const renderStr = genElement(ast);\r\n\r\n    return new Function(`with(this) { return ${renderStr} }`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} ast \r\n */\r\nfunction genElement(ast) {\r\n    const { tag, rawAttr, attr } = ast;\r\n\r\n    const attrs = { ...rawAttr, ...attr };\r\n\r\n    // 处理子节点，得到一个所有子节点渲染函数组成的数组\r\n    const children = genChildren(ast.children);\r\n\r\n    return `_c('${tag}', ${JSON.stringify(attrs)}, [${children}])`;\r\n}\r\n\r\n/**\r\n * 处理子节点\r\n * @param {*} children \r\n */\r\nfunction genChildren(children) {\r\n    const ret = [];\r\n\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n\r\n        if (child.type === 3) {\r\n            // 处理文本节点\r\n            ret.push(`_v(${JSON.stringify(child)})`);\r\n        } else if (child.type === 1) {\r\n            // 元素节点\r\n            ret.push(genElement(child));\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}","import Watcher from \"../watcher\";\r\n\r\n/**\r\n * 挂载\r\n * @param { Vue } vm \r\n */\r\nexport function mountComponent(vm) {\r\n\r\n    const updateComponent = () => {\r\n        vm._update(vm._render());\r\n    }\r\n\r\n    new Watcher(updateComponent);\r\n}\r\n\r\n\r\nexport function mixinRender(Vue) {\r\n    Vue.prototype._render = function() {\r\n        return this.$options.render.call(this);\r\n    }\r\n\r\n    Vue.prototype._update = function(vnode) {\r\n        // 获取旧的 VNode\r\n        const prevVNode = this._vnode;\r\n        // 更新实例上的 VNode\r\n        this._vnode = vnode;\r\n\r\n        if (!prevVNode) {\r\n            // 旧的 VNode 不存在，说明首次渲染\r\n            this.$el = this.__patch__(this.$el, vnode);\r\n        } else {\r\n            // 后续更新走这里\r\n            this.$el = this.__patch__(prevVNode, vnode);\r\n        }\r\n    }\r\n}","import Vue from \"../vue\";\r\nimport { isReserveTag } from '../src/utils';\r\n/**\r\n * \r\n * @param { Element|VNode } oldVnode 旧的 VNode 或者真实元素\r\n * @param { VNode } vnode \r\n */\r\nexport default function patch(oldVnode, vnode) {\r\n    if (oldVnode && !vnode) {\r\n        // 1、旧的节点存在，而新的节点不存在，则销毁组件\r\n        return;\r\n    }\r\n    if (!oldVnode) {\r\n        // 2、旧的节点不存在，说明子组件首次渲染\r\n        createElm(vnode);\r\n    } else {\r\n        if (oldVnode.nodeType) { // 表示真实元素，表示首次渲染根组件\r\n            // 获取父节点，即 body\r\n            const parent = oldVnode.parentNode;\r\n\r\n            const referNode = oldVnode.nextSibling;\r\n\r\n            createElm(vnode, parent, referNode);\r\n\r\n            parent.removeChild(oldVnode);\r\n        } else {\r\n            // ...\r\n        }\r\n    }\r\n    return vnode.elm;\r\n}\r\n\r\n/**\r\n * 创建元素\r\n * @param { VNode } vnode VNode 虚拟节点\r\n * @param { Element } parent 虚拟节点的父节点 真实元素\r\n * @param { Element|null } referNode \r\n */\r\nfunction createElm(vnode, parent, referNode) {\r\n\r\n    vnode.parent = parent;\r\n    // 判断是否为组件\r\n    if (createComponent(vnode)) return;\r\n\r\n    const { attr, children, text } = vnode;\r\n\r\n    if (text) {\r\n        // 1、文本节点\r\n        vnode.elm = createTextNode(vnode);\r\n    } else {\r\n        // 2、元素节点\r\n        vnode.elm = document.createElement(vnode.tag);\r\n\r\n        // 给元素设置属性\r\n        setAttribute(attr, vnode);\r\n\r\n        // 递归子节点\r\n        for (let i = 0; i < children.length; i++) {\r\n            createElm(children[i], vnode.elm);\r\n        }\r\n    }\r\n\r\n    // 如果有父节点，即将创建的元素添加到父节点内\r\n    if (parent) {\r\n        const elm = vnode.elm;\r\n        if (referNode) {\r\n            parent.insertBefore(elm, referNode);\r\n        } else {\r\n            parent.appendChild(elm);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 创建文本节点\r\n * @param {*} textVNode \r\n */\r\nfunction createTextNode(textVNode) {\r\n    const text = textVNode.text;\r\n    let textNode = null;\r\n    if (text.expression) {\r\n        // 存在表达式，这个表达式的值是一个响应式数据\r\n        const value = textVNode.context[text.expression];\r\n\r\n        textNode = document.createTextNode(typeof value === 'object' ? JSON.stringify(value) : String(value));\r\n    } else {\r\n        // 纯文本\r\n        textNode = document.createTextNode(text.text);\r\n    }\r\n    return textNode;\r\n}\r\n\r\n/**\r\n * 给节点设置属性\r\n * @param {*} attr \r\n * @param {*} vnode \r\n */\r\nfunction setAttribute(attr, vnode) {\r\n    for (let key in attr) {\r\n        if (key === 'vModel') {\r\n            // v-model 指令\r\n            const { tag, value } = attr.vModel\r\n            setVModel(tag, value, vnode);\r\n        } else if (key === 'vBind') {\r\n            // v-bind\r\n            setVBind(attr[key], vnode);\r\n        } else if (key === 'vOn') {\r\n            // v-on\r\n            setVOn(attr[key], vnode);\r\n        } else {\r\n            // 普通属性\r\n            vnode.elm.setAttribute(key, attr[key]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * v-model 属性处理\r\n * @param {*} tag \r\n * @param {*} value \r\n * @param {*} vnode \r\n */\r\nfunction setVModel(tag, value, vnode) {\r\n    const { context: vm, elm } = vnode;\r\n\r\n    if (tag === 'select') {\r\n        // 这里为啥用 Promise，因为子元素 option 还没创建呢\r\n        Promise.resolve().then(() => {\r\n            elm.value = vm[value];\r\n        });\r\n        elm.addEventListener('change', function() {\r\n            vm[value] = elm.value;\r\n        })\r\n    } else if (tag === 'input' && vnode.elm.type === 'text') {\r\n        elm.value = vm[value];\r\n\r\n        elm.addEventListener('input', function() {\r\n            vm[value] = elm.value;\r\n        })\r\n    } else if (tag === 'input' && vnode.elm.type === 'checkbox') {\r\n        elm.checked = vm[value];\r\n        elm.addEventListener('change', function() {\r\n            vm[value] = elm.checked;\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * 处理 v-bind\r\n * @param {*} vBind \r\n * @param {*} vnode \r\n */\r\nfunction setVBind(vBind, vnode) {\r\n    const { elm, context: vm } = vnode;\r\n\r\n    for (let attrName in vBind) {\r\n        elm.setAttribute(attrName, vm[vBind[attrName]]);\r\n\r\n        elm.removeAttribute(`v-bind:${attrName}`);\r\n    }\r\n}\r\n\r\n/**\r\n * 处理 v-on\r\n * @param {*} vOn \r\n * @param {*} vnode \r\n */\r\nfunction setVOn(vOn, vnode) {\r\n    const { elm, context: vm } = vnode;\r\n\r\n    for (let eventName in vOn) {\r\n        elm.addEventListener(eventName, function(...args) {\r\n            vm.$options.methods[vOn[eventName]].apply(vm, args);\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * 创建组件\r\n * @param {*} vnode \r\n */\r\nfunction createComponent(vnode) {\r\n    if (vnode.tag && !isReserveTag(vnode.tag)) {\r\n        // 非保留节点，则说明是组件\r\n        // 获取组件配置信息\r\n        const { tag, context: { $options: { components } } } = vnode;\r\n\r\n        const componentOptions = components[tag];\r\n\r\n        const componentInstance = new Vue(componentOptions);\r\n\r\n        // 将父组件的 VNode 放到子组件的实例 __parentVnode 上\r\n        componentInstance._parentVnode = vnode;\r\n\r\n        componentInstance.$mount();\r\n\r\n        componentInstance._vnode.parent = vnode.parent;\r\n\r\n        // 将子组件添加到父节点内\r\n        vnode.parent.appendChild(compIns._vnode.elm)\r\n\r\n        return true;\r\n    }\r\n}","import VNode from './vnode';\r\n\r\n/**\r\n * 渲染辅助函数\r\n * @param {*} target \r\n */\r\nexport default function renderHelper(target) {\r\n    target._c = createElement;\r\n    target._v = createTextNode;\r\n}\r\n\r\n/**\r\n * 创建 VNode\r\n * @param {*} tag 标签名\r\n * @param {*} attr 属性\r\n * @param {*} children \r\n */\r\nfunction createElement(tag, attr, children) {\r\n    return new VNode(tag, attr, children, this);\r\n}\r\n\r\n/**\r\n * 文本节点 VNode\r\n * @param {*} textAst \r\n */\r\nfunction createTextNode(textAst) {\r\n    return new VNode(null, null, null, this, textAst);\r\n}\r\n","export default class VNode {\r\n    /**\r\n     * \r\n     * @param {*} tag \r\n     * @param {*} attr \r\n     * @param {*} children \r\n     * @param {*} context \r\n     * @param {*} text \r\n     */\r\n    constructor(tag, attr, children, context, text = null) {\r\n        this.tag = tag;\r\n        this.attr = attr;\r\n        this.children = children;\r\n        this.parent = null;\r\n        this.text = text;\r\n        this.elm = null;\r\n        this.context = context;\r\n    }\r\n}","export default class Dep {\r\n    // 存储当前 dep 收集到的 watcher\r\n    watchers = [];\r\n\r\n    // 收集 watcher\r\n    // 在发生读取操作时（vm.xx) && 并且 Dep.target 不为 null 时进行依赖收集\r\n    depend() {\r\n        // 防止 Watcher 实例被重复收集\r\n        if (!Dep.target || this.watchers.includes(Dep.target)) return;\r\n\r\n        this.watchers.push(Dep.target);\r\n    }\r\n\r\n    // dep 通知自己收集的所有 watcher 执行更新函数\r\n    notify() {\r\n        for (let watcher of this.watchers) {\r\n            watcher.update();\r\n        }\r\n    }\r\n}\r\n\r\n// 是一个静态属性\r\nDep.target = null;\r\n\r\n","import { protoArgument } from './protoArgument';\r\nimport { defineReactive } from './utils';\r\nimport Dep from './dep';\r\n/**\r\n * 响应式设置\r\n * @param { any } value \r\n */\r\nexport function observe(value) {\r\n    if (value === null || typeof value !== 'object') return;\r\n\r\n    // 表示对象已经 经过响应式处理\r\n    if (value.__ob__) return value.__ob__;\r\n\r\n    return new Observer(value);\r\n}\r\n\r\nexport default class Observer {\r\n    constructor(value) {\r\n        this.dep = new Dep();\r\n        \r\n        Object.defineProperty(value, '__ob__', {\r\n            value: this,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n\r\n        if (Array.isArray(value)) {\r\n            // 数组响应式\r\n            protoArgument(value)\r\n            this.observeArray(value);\r\n        } else {\r\n            this.walk(value);\r\n        }\r\n    }\r\n\r\n    walk(data) {\r\n        for (let key in data) {\r\n            defineReactive(data, key, data[key]);\r\n        }\r\n    }\r\n\r\n    observeArray(arr) {\r\n        for (let item of arr) {\r\n            observe(item);\r\n        }\r\n    }\r\n}","const arrProto = Array.prototype;\r\n\r\nconst arrayMethods = Object.create(arrProto);\r\n\r\nconst methodsToPatch = ['push', 'pop', 'unshift', 'shift', 'splice', 'sort', 'reverse'];\r\n\r\n// 数组的变异方法\r\nmethodsToPatch.forEach((method) => {\r\n    Object.defineProperty(arrayMethods, method, {\r\n        value: function(...args) {\r\n            const result = arrProto[method].apply(this, args);\r\n\r\n            // 拦截这几个操作数组的方法，数组改变时通知依赖更新\r\n            let inserted = [];\r\n            switch(method) {\r\n                case 'push':\r\n                case 'unshift':\r\n                    inserted = args;\r\n                    break;\r\n                case 'splice':\r\n                    inserted = args.slice(2);\r\n                    break;\r\n                default:\r\n                    inserted = [];\r\n            }\r\n            // 表示数组元素增加，增加部分需要设置响应式\r\n            if (inserted.length > 0) {\r\n                this.__ob__.observeArray(args);\r\n            }\r\n            // 通知依赖更新\r\n            this.__ob__.dep.notify();\r\n\r\n            return result;\r\n        },\r\n        configurable: true,\r\n        writable: true,\r\n        enumerable: true\r\n    })\r\n})\r\n\r\nexport function protoArgument(arr) {\r\n    Object.setPrototypeOf(arr, arrayMethods);\r\n}","/**\r\n * 是否为平台保留节点\r\n * @param {*} tagName \r\n */\r\nexport function isReserveTag(tagName) {\r\n    const reserveTag = ['div', 'h3', 'span', 'input', 'select', 'option', 'p', 'button', 'template'];\r\n    return reserveTag.includes(tagName);\r\n}","import Dep from './dep';\r\nimport { observe } from './observer';\r\n\r\n/**\r\n * 将 sourceKey 属性代理到 target 上\r\n * @param { Vue } vm\r\n * @param { Object }\r\n * @param { String } key 属性名\r\n */\r\nexport function proxy(target, sourceKey, key) {\r\n    Object.defineProperty(target, key, {\r\n        get() {\r\n            // 读取 vm.xx 实际上返回的是 vm[sourceKey].xx\r\n            return target[sourceKey][key];\r\n        },\r\n        set(value) {\r\n            // vm.xx = value 实际上是对 target[sourceKey][key] 赋值\r\n            target[sourceKey][key] = value;\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * 通过 Object.defineProperty 设置 getter setter 拦截\r\n * @param {*} obj \r\n * @param {*} key \r\n * @param {*} value \r\n */\r\nexport function defineReactive(obj, key, value) {\r\n    const childOb = observe(value);\r\n\r\n    const dep = new Dep();\r\n\r\n    Object.defineProperty(obj, key, {\r\n        get() {\r\n            if (Dep.target) {\r\n                console.log(dep)\r\n                dep.depend();\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                }\r\n            }\r\n            return value;\r\n        },\r\n        set(newVal) {\r\n            if (newVal === value) return;\r\n\r\n            value = newVal;\r\n            // 对新值进行响应式处理\r\n            observe(newVal);\r\n\r\n            // 通知依赖更新\r\n            dep.notify();\r\n        }\r\n    })\r\n}","import { proxy } from './utils';\r\nimport { observe } from './observer';\r\nimport { mount } from './compiler2';\r\nimport { mixinRender } from './compiler2/mountComponent';\r\nimport renderHelper from './compiler2/renderHelper';\r\nimport patch from './compiler2/patch';\r\nimport Watcher from './watcher';\r\n\r\nfunction Vue(options) {\r\n    debugger\r\n    this._init(options);\r\n}\r\n\r\nVue.prototype._init = function(options) {\r\n    const vm = this;\r\n    vm.$options = options;\r\n\r\n    initData(vm);\r\n\r\n    renderHelper(this);\r\n\r\n    this.__patch__ = patch;\r\n\r\n    if (vm.$options.el) {\r\n        this.$mount()\r\n    }\r\n}\r\n\r\nmixinRender(Vue);\r\n\r\nVue.prototype.$mount = function () {\r\n    mount(this);\r\n}\r\n\r\nfunction initData(vm) {\r\n    const data = vm.$options.data;\r\n\r\n    if (!data) {\r\n        vm._data = {};\r\n    } else {\r\n        vm._data = typeof data === 'function' ? data() : data;\r\n    }\r\n\r\n    // 将 _data 属性代理到 vm 上\r\n    for (let key in vm._data) {\r\n        proxy(vm, '_data', key);\r\n    }\r\n\r\n    // 设置响应式\r\n    observe(vm._data);\r\n\r\n    new Watcher(function() {\r\n        console.log('更新啦');\r\n    });\r\n}\r\n\r\n\r\nexport default Vue;\r\n","import Dep from './dep';\r\n\r\nexport default class Watcher {\r\n    constructor(cb) {\r\n        this._cb = cb;\r\n\r\n        Dep.target = this;\r\n        // 执行 cb 函数，cb 函数中会发生 vm.xx 的属性读取，进行依赖收集\r\n        cb();\r\n        // 依赖收集完成，Dep.target 重新赋值为 null，防止重复收集\r\n        Dep.target = null;\r\n    }\r\n\r\n    // 响应式数据更新时，dep 通知 watcher 执行 update 方法\r\n    update() {\r\n        this._cb();\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./vue.js\");\n",""],"names":[],"sourceRoot":""}